{
    "collab_server" : "",
    "contents" : "source(\"log.fit.R\") ##script for fitting models\n\n##Specify the input file\n##this file represents the processed size data after time points with issues near the end have been removed\n\ntime_points_removed = readline(\"Do you want to use data with time points removed? (Y/N):\\n\")\n\nif(time_points_removed == \"Y\"){\n  file = \"../Process/time_points_removed.tab\"\n} else if(time_points_removed == \"N\"){\n  file = \"../Process/all_time_points.tab\"\n} else{\n  stop(\"Invalid input. Please answer the question with Y or N. Re-run the script.\")\n}\n\nfile = \"../Process/time_points_removed.tab\"\n\n##specify the desired class for each column of data\nclasses = c(\"numeric\",\"numeric\",\"character\",\"numeric\",\"factor\",\"numeric\",\"factor\",\"factor\",  \"factor\", \"character\")\n#           Row        Col         Name    Size     Media     Timepoint Temp    Array(1-6)   \"Condition   \"Well\"  \n\n##read in the data\ndf = read.table(file,header=T, colClasses=classes,sep=\"\\t\")\n\n##Specify an output data frame to serve as a frame of reference\n##the output data frame is identical to the initial data frame in format\n##however, for each Strain, there will only be one row of data, instead of one for each time point\n##So we subset the initial dataframe for just one time point\nout_df = subset(df, df$Time.Point == 0)\n\n##specify place holder vectors for our output variables\nCC = vector(length=nrow(out_df)) ##carrying capacity\nR = vector(length=nrow(out_df)) ##rate of growth\nMinSize = vector(length = nrow(out_df)) ##initial population size\nCorr = vector(length = nrow(out_df)) ##correlation of the model fit\n\n\n##compile the place holder vectors into a single list\n##so they can be passed through functions as a single variable\nreturn_vectors = list(CC,R,MinSize,Corr) \nnames(return_vectors) = c(\"CC\",\"R\",\"MinSize\",\"Corr\") #add names\n\n####SPECIFY FUNCTIONS FOR HANDLING NORMAL CASES OR ERRORS\n##The model can fail to fit the data for multiple reasons\n##When this happens, the code will throw an error\n##We want our code to continue when an error occurs\n##and record information about which specific condition, strain, and spot caused the error\n\n##To achieve this we will leverage the power of the tryCatch function in R\n## tryCatch requires an expression you are trying to evaluate\n## and a function to call when an error occurs\n## We specify a function for each to handle the complexity of the call\n\n##NORMAL_CASE\n\n## During execution, this function is called to attempt to fit a model\n## to the data for a single condition, strain, and spot\n## takes in the list of output vectors\n## and fills in the data for that specific condition, strain and spot\n## each call to this function fills in one more \"row\" of the output vectors\n\n##rv = the list of place holder vectors to be filled with output data\n##subSpot = the data.frame containing data for the specific \n\nnormal_case = function(rv,subSpot){\n  ##fit the model by calling the log.fit function (separate R script)\n  fm = log.fit(\"Size\",\"Time.Point\",subSpot) \n  \n  ##fill in specific rows of the vectors of output data\n  ##based on matching the correct row in the output data frame\n  rv$CC[out_df$Condition == condition & \n          out_df$Array == array & \n          out_df$Gene == strain & \n          out_df$Well == spot] = fm[[1]][1] #Carrying capacity\n  \n  rv$R[out_df$Condition == condition & \n         out_df$Array == array & \n         out_df$Gene == strain & \n         out_df$Well == spot] = fm[[1]][2] #rate of growth\n  \n  rv$MinSize[out_df$Condition == condition & \n               out_df$Array == array & \n               out_df$Gene == strain & \n               out_df$Well == spot] = fm[[1]][3] #initial population size\n  \n  rv$Corr[out_df$Condition == condition & \n               out_df$Array == array & \n               out_df$Gene == strain & \n               out_df$Well == spot] = fm[[1]][4] #correlation\n  \n  ##return vectors of output data with output filled in\n  ##for the specific condition, strain, and spot analyzed\n  return(rv) \n}\n\n##ERROR_CASE\n\n##This function is run by tryCatch when an error is encountered\n##The function does not try to fit a model, as the model failure to fit caused the error\n##Instead, output is recored as \"OMIT\" in each output vector\n\n##err = error message encountered during execution of normal_case()\n\nerror_case = function(err){\n  ##we have to modify return_vectors directly here\n  ##the error function in tryCatch has no clear way to accept them as a parameter\n  title = paste(\"Logistic Fit Failure\",subSpot$Condition[1],subSpot$Gene[1],subSpot$Well[1])\n  \n  print(ggplot(aes(Time.Point,Size),data=subSpot) +\n          geom_point() +\n          ggtitle(title)\n  )\n  ##save the graph, user must have previously created \"model_success_graphs\" folder\n  ggsave(paste(title,\"png\",sep=\".\"),path=\"model_failure_graphs\")\n  \n  \n  return_vectors$CC[out_df$Condition == condition &\n                      out_df$Array == array &\n                      out_df$Gene == strain &\n                      out_df$Well == spot] = c(\"OMIT\")\n  \n  return_vectors$R[out_df$Condition == condition &\n                     out_df$Array == array &\n                     out_df$Gene == strain &\n                     out_df$Well == spot] = c(\"OMIT\")\n  \n  return_vectors$MinSize[out_df$Condition == condition &\n                           out_df$Array == array &\n                           out_df$Gene == strain &\n                           out_df$Well == spot] = c(\"OMIT\")\n  \n  return_vectors$Corr[out_df$Condition == condition & \n            out_df$Array == array & \n            out_df$Gene == strain & \n            out_df$Well == spot] = c(\"OMIT\")\n  \n  print(paste('ERROR',subSpot$Gene,subSpot$Condition,subSpot$Well))\n  return(return_vectors)\n}\n\n\n####LOOP THROUGH THE DATA TO FIT THE MODEL\n\n##make folders for graphs\ndir.create(\"model_success_graphs\")\ndir.create(\"model_failure_graphs\")\n\n##delete old graphs\ndo.call(file.remove, list(list.files(\"model_success_graphs\", full.names = TRUE)))\ndo.call(file.remove, list(list.files(\"model_failure_graphs\", full.names = TRUE)))\n\n##start by getting a list of each unique condition\nconditions = sort(unique(df$Condition))\n\n\nfor(condition in conditions){\n  ##subset the data for that condition\n  subCondition = subset(df,df$Condition == condition)\n  \n  ##get a unique list of arrays in that condition\n  arrays = sort(unique(subCondition$Array))\n  \n  \n  for(array in arrays){\n    ##subset the data for that specific array\n    subArray = subset(subCondition, subCondition$Array == array)\n    ##get a unique list of strain names within that condition\n    strains = sort(unique(subArray$Gene))\n    \n    for(strain in strains){\n      ##subset the data for that specific strain\n      subStrain = subset(subArray, subArray$Gene == strain)\n      \n      ##get a unique list of spots\n      ##each spot represents 1 technical replicate for that strain\n      spots = sort(unique(subStrain$Well))\n      \n      for(spot in spots){\n        ##data for all time points for a particular spot\n        subSpot = subset(subStrain, subStrain$Well == spot)\n        \n        ##sort by time point ascending\n        subSpot = subSpot[order(subSpot$Time.Point),]\n        \n        ##Turn values where size = 0 intonitial size = 1\n        ##You can't have growth from a non-existent population so this causes model to fail\n        \n        subSpot$Size[subSpot$Size == 0] = 1\n        \n\n        ##Run the functions to fit the model\n        ##This will fill in the output vector with the data\n        ##or with \"OMIT\" if an error is encountered\n        return_vectors = tryCatch(\n          normal_case(return_vectors,subSpot),\n          error = error_case)\n          \n      }\n    }\n  }\n}\n\n##Note: These vectors are character so that the OMITS can be includeded\n##add the output vectors as columns to the output data.frame\nout_df$CC = return_vectors$CC\nout_df$R = return_vectors$R\nout_df$MinSize= return_vectors$MinSize\nout_df$Corr = return_vectors$Corr\n\n#remove unnecessary columns from data.frame\n\nout_df = out_df[,c(1,2,3,5,7,8,9,10,11,12,13,14)]\n\n####Write the output to a tab delimited file\nwrite.table(out_df,\"logistic_growth.tab\",row.names=F,sep=\"\\t\")\n\nprint(\"DONE\")\n\n",
    "created" : 1502821497652.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2951839010",
    "id" : "5338F55F",
    "lastKnownWriteTime" : 1505494879,
    "last_content_update" : 1505494879736,
    "path" : "~/Sequencing_Research/Tools_&_Data/Robot Image Analysis Development/Robot Image Analysis 2.0.1/LogisticGrowth/fit_logistic_growth.R",
    "project_path" : "fit_logistic_growth.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}